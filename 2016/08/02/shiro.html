<!DOCTYPE HTML>
<html class="no-js" lang="zh-CN">
<!--
//                            _ooOoo_
//                           o8888888o
//                           88" . "88
//                           (| -_- |)
//                            O\ = /O
//                        ____/`---'\____
//                      .   ' \\| |// `.
//                       / \\||| : |||// \
//                     / _||||| -:- |||||- \
//                       | | \\\ - /// | |
//                     | \_| ''\---/'' | |
//                      \ .-\__ `-` ___/-. /
//                   ___`. .' /--.--\ `. . __
//                ."" '< `.___\_<|>_/___.' >'"".
//               | | : `- \`.;`\ _ /`;.`/ - ` : | |
//                 \ \ `-. \_ __\ /__ _/ .-` / /
//         ======`-.____`-.___\_____/___.-`____.-'======
//                            `=---='
//                 拦截插件累计拦截逗比攻击"1381438"次！
//         .............................................
//                  佛祖保佑             永无BUG
//          佛曰:
//                  写字楼里写字间，写字间里程序员；
//                  程序人员写程序，又拿程序换酒钱。
//                  酒醒只在网上坐，酒醉还来网下眠；
//                  酒醉酒醒日复日，网上网下年复年。
//                  但愿老死电脑间，不愿鞠躬老板前；
//                  奔驰宝马贵者趣，公交自行程序员。
//                  别人笑我忒疯癫，我笑自己命太贱；
//                  不见满街漂亮妹，哪个归得程序员？
-->
<head><meta name="generator" content="Hexo 3.9.0">
    <!--[if lte IE 9]>
<meta http-equiv="refresh" content="0;url=http://wuzguo.com/blog/warn.html">
<![endif]-->
<meta charset="utf-8">

<meta http-equiv="X-UA-Compatible" content="IE=Edge">
<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no">
<meta http-equiv="mobile-agent" content="format=html5; url=http://wuzguo.com/blog">
<meta name="author" content="Zàk (https://github.com/wuzguo)">
<link rel="stylesheet" href="/blog/css/SimpleStyle.css">

<!--代码高亮-->
<link rel="stylesheet" href="/blog/css/highlight/styles/default.css">
<!--使用Github风格的代码样式-->
<link rel="stylesheet" href="/blog/css/highlight/styles/github.css">

<link rel="shortcut icon" href="/blog/images/fav.ico">


<title>
    
    shiro学习笔记 -
    
    Zak&#39;s Home
    
</title>

<meta name="keywords" content="shiro">

<meta name="description " content="Apache Shiro权限管理框架的使用">
</head>
<body>
<div id="nav">
    <nav class="nav-menu">
        <a class="site-name current" href="/blog/" title="Zàk">Zàk</a>
        <a class="site-index current" href="/blog/"><i class="fa fa-home"></i><span>首页</span></a>
        <a href="/blog/archives/" title="归档"><i class="fa fa-archives"></i><span>归档</span></a>
        <a href="/blog/tags/" title="标签"><i class="fa fa-tags"></i><span>标签</span></a>
        <a href="/blog/video/" title="视频"><i class="fa fa-video-camera"></i><span>视频</span></a>
        <a href="/blog/cross_fire/" title="链接"><i class="fa fa-wifi"></i><span>链接</span></a>
        <a href="/blog/help/" title="帮助"><i class="fa fa-question-circle"></i><span>帮助</span></a>
    </nav>
</div>
<div class="nav-user">
    <a class="btn-search" href="#"><i class="fa fa-search"></i></a>
    <a class="btn-read-mode" href="#"><i class="fa fa-sun-o"></i></a>
    <a class="btn-weixin-mp" href="javascript:"><i class="fa fa-weixin"></i></a>
</div>
<div id="wrapper" class="clearfix">
    <div id="body">
        <div class="main" id="main">
            <div id="cover">
    <div class="cover-img"></div>
    <div class="cover-info">
        <img class="avatar" width="72" src="/blog/images/avatar.png" alt="avatar">
        <h1>Zàk</h1>
        <h4>日拱一卒，功不唐捐</h4>
        <p>一个追求进步的码农的博客</p>
        <div class="cover-sns">
            <div class="btn btn-homepage">
                <a href="http://wuzguo.com" target="_blank" rel="nofollow"><i class="fa fa-homepage"></i></a>
            </div>
            <div class="btn btn-github">
                <a href="https://github.com/wuzguo" target="_blank" rel="nofollow"><i class="fa fa-github"></i></a>
            </div>
            <div class="btn btn-stack-overflow">
                <a href="https://stackoverflow.com/users/6716643/wuzguo" target="_blank" rel="nofollow"><i class="fa fa-stack-overflow"></i></a>
            </div>
            <div class="btn btn-facebook">
                <a href="https://www.facebook.com/wu.xsen" target="_blank" rel="nofollow"><i class="fa fa-facebook"></i></a>
            </div>
        </div>
    </div>
</div>
            <div class="page-title">
    <ul>
        <li><a href="/blog/">最新</a></li>
        
            
                <li class="active">
                    <a href="/blog/categories/server/" data-name="后台">后台</a>
                </li>
            
                <li class>
                    <a href="/blog/categories/front/" data-name="前端">前端</a>
                </li>
            
                <li class>
                    <a href="/blog/categories/db/" data-name="数据库">数据库</a>
                </li>
            
                <li class>
                    <a href="/blog/categories/os/" data-name="操作系统">操作系统</a>
                </li>
            
                <li class>
                    <a href="/blog/categories/iot/" data-name="IoT">IoT</a>
                </li>
            
                <li class>
                    <a href="/blog/categories/bigdata/" data-name="大数据">大数据</a>
                </li>
            
                <li class>
                    <a href="/blog/categories/tools/" data-name="工具">工具</a>
                </li>
            
                <li class>
                    <a href="/blog/categories/others/" data-name="其他">其他</a>
                </li>
            
        
        <li class="page-search">
    <form id="search" class="search-form">
        <label for="s" class="sr-only">请输入关键字</label>
        <input class="search-field" type="text" name="s" placeholder="请输入关键字">
        <button type="submit" class="search-form-submit" title="搜索"><i class="fa fa-search"></i></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/blog/',
        CONTENT_URL: '/blog/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
</li>

    </ul>
</div>
<div class="main-inner">
    <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
        <div class="post-header">
            <div class="post-author clearfix">
                <a class="avatar fleft" href="http://www.wuzguo.com" target="_blank">
                    <img width="48" src="/blog/images/avatar.png" alt="avatar">
                </a>
                <p><span class="label">作者</span>
                    <a href="https://github.com/wuzguo" target="_blank">Zak</a>
                    <span title="最后编辑于2016-08-02">2016-08-02</span>
                </p>
                <p>一个追求进步的「十八线码农」</p>
            </div>
            <h2 class="post-title">Shiro学习笔记</h2>
            <div class="post-meta">
                本文总共22855个字 | 您是第<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>位看到它们的小伙伴
            </div>
        </div>
        <div class="post-content markdown-body">
            <p>1.Shiro介绍<br>Apache Shiro是一个强大易用的Java安全框架，提供了认证、授权、加密和会话管理等功能：</p>
<ul>
<li>认证 用户身份识别，常被称为用户“登录”</li>
<li>授权 访问控制</li>
<li>密码加密 保护或隐藏数据防止被偷窥</li>
<li>会话管理 每用户相关的时间敏感的状态</li>
</ul>
<p>对于任何一个应用程序，Shiro都可以提供全面的安全管理服务。并且相对于其他安全框架，Shiro要简单的多。</p>
<p>2.Shiro架构<br>首先，来了解一下Shiro的三个核心组件：Subject, SecurityManager 和 Realms. 如下图：<br><img src="/blog/images/201608/1.png" alt></p>
<p>Subject：即“当前操作用户”。但是，在Shiro中，Subject这一概念并不仅仅指人，也可以是第三方进程、后台帐户（Daemon Account）或其他类似事物。它仅仅意味着“当前跟软件交互的东西”。但考虑到大多数目的和用途，你可以把它认为是Shiro的“用户”概念。<br>Subject代表了当前用户的安全操作，SecurityManager则管理所有用户的安全操作。</p>
<p>SecurityManager：它是Shiro框架的核心，典型的Facade模式，Shiro通过SecurityManager来管理内部组件实例，并通过它来提供安全管理的各种服务。<br>SecurityManager默认实现结构：<br><img src="/blog/images/201608/5.png" alt></p>
<p>Realm：域，Shiro从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。<br>从这个意义上讲，Realm实质上是一个安全相关的DAO：它封装了数据源的连接细节，并在需要时将相关数据提供给Shiro。当配置Shiro时，你必须至少指定一个Realm，用于认证和（或）授权。配置多个Realm是可以的，但是至少需要一个。</p>
<p>Shiro内置了可以连接大量安全数据源（又名目录）的Realm，如LDAP、关系数据库（JDBC）、类似INI的文本配置资源以及属性文件等。如果缺省的Realm不能满足需求，你还可以插入代表自定义数据源的自己的Realm实现。</p>
<p>Shiro缺省Realm实现：<br><img src="/blog/images/201608/4.png" alt></p>
<p>实现自己的Realm<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(UserRealm<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清楚授权的缓存，授权缓存以用户对象为键</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> principals</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">clearCachedAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">"[UserRealm] clearCachedAuthorizationInfo begin"</span>);</span><br><span class="line">        Cache cache = <span class="keyword">this</span>.getAuthorizationCache();</span><br><span class="line">        Set&lt;Object&gt; keys = cache.keys();</span><br><span class="line">        <span class="keyword">for</span> (Object object : keys) &#123;</span><br><span class="line">            logger.debug(<span class="string">"[UserRealm] clearCachedAuthorizationInfo object: "</span> + object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.clearCachedAuthorizationInfo(principals);</span><br><span class="line">        logger.debug(<span class="string">"[UserRealm] clearCachedAuthorizationInfo end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权，如果不使用缓存，每次访问新页面都会执行这个方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> principals</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        User user = ((User) principals.getPrimaryPrincipal());</span><br><span class="line">        String code = user.getCode();</span><br><span class="line">        System.out.println(user.getId() + <span class="string">","</span> + user.getNickname());</span><br><span class="line">        List&lt;Role&gt; roles = userService.listRoleByUserCode(code);</span><br><span class="line">        List&lt;AuthResource&gt; authResources = userService.listResByUserCode(code);</span><br><span class="line">        List&lt;String&gt; permissions = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (AuthResource resource : authResources) &#123;</span><br><span class="line">            permissions.add(resource.getUrl());</span><br><span class="line">        &#125;</span><br><span class="line">        SimpleAuthorizationInfo info = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">        <span class="comment">// info.setRoles(new HashSet&lt;String&gt;(roles));</span></span><br><span class="line">        info.setStringPermissions(<span class="keyword">new</span> HashSet&lt;String&gt;(permissions));</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除认证的缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> principals</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">clearCachedAuthenticationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">"[UserRealm] clearCachedAuthenticationInfo begin"</span>);</span><br><span class="line"></span><br><span class="line">        Cache cache = <span class="keyword">this</span>.getAuthenticationCache();</span><br><span class="line">        Set&lt;Object&gt; keys = cache.keys();</span><br><span class="line">        <span class="keyword">for</span> (Object object : keys) &#123;</span><br><span class="line">            logger.debug(<span class="string">"[UserRealm] clearCachedAuthorizationInfo object: "</span> + object);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 认证的缓存以用户名为键，需要手动处理，否则退出登录时登录信息将不能被清除</span></span><br><span class="line">        User user = ((User) principals.getPrimaryPrincipal());</span><br><span class="line">        SimplePrincipalCollection simplePrincipalCollection = <span class="keyword">new</span> SimplePrincipalCollection(user.getUsername(), <span class="keyword">this</span>.getName());</span><br><span class="line">        <span class="keyword">super</span>.clearCachedAuthenticationInfo(simplePrincipalCollection);</span><br><span class="line">        logger.debug(<span class="string">"[UserRealm] clearCachedAuthenticationInfo end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取认证信息，登录的时候调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AuthenticationException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String username = token.getPrincipal().toString();</span><br><span class="line">        String password = <span class="keyword">new</span> String((<span class="keyword">char</span>[]) token.getCredentials());</span><br><span class="line">        <span class="comment">// 获取用户信息</span></span><br><span class="line">        User user = userService.doGetUserInfo(username, password);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.debug(<span class="string">"[UserRealm] doGetAuthenticationInfo user is null"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationException(<span class="string">"username invalid"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SimpleAuthenticationInfo info = <span class="keyword">new</span> SimpleAuthenticationInfo(user, user.getSerct(), <span class="keyword">this</span>.getName());</span><br><span class="line">        <span class="comment">// 设置Salt值，增强密码破解的难度</span></span><br><span class="line">        info.setCredentialsSalt(ByteSource.Util.bytes(user.getUsername()));</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>Shiro完整架构图：</p>
<p><img src="/blog/images/201608/2.png" alt></p>
<p>3.Shiro认证与授权<br>认证就是验证用户身份的过程。在认证过程中，用户需要提交实体信息(Principals)和凭据信息(Credentials)以检验用户是否合法。最常见的“实体/凭证”组合便是“用户名/密码”组合。被 Shiro 保护的资源，才会经过认证与授权过程。使用 Shiro 对 URL 进行保护可以参见“与 Spring 集成”章节。用户访问受 Shiro 保护的 URL；例如 <a href="http://host/security/action.do，Shiro">http://host/security/action.do，Shiro</a> 首先检查用户是否已经通过认证，如果未通过认证检查，则跳转到登录页面，否则进行授权检查。认证过程需要通过 Realm 来获取用户及密码信息，通常情况我们实现 JDBC Realm，此时用户认证所需要的信息从数据库获取。如果使用了缓存，除第一次外用户信息从缓存获取。认证通过后接受 Shiro 授权检查，授权检查同样需要通过 Realm 获取用户权限信息。Shiro 需要的用户权限信息包括 Role 或 Permission，可以是其中任何一种或同时两者，具体取决于受保护资源的配置。如果用户权限信息未包含 Shiro 需要的 Role 或 Permission，授权不通过。只有授权通过，才可以访问受保护 URL 对应的资源，否则跳转到“未经授权页面”。</p>
<p>3.1 身份认证流程<br>1.首先创建一个SecurityManager工厂<br>2.接着获取SecurityManager并绑定到SecurityUtils，这是一个全局设置，设置一次即可；<br>3.通过SecurityUtils得到Subject，其会自动绑定到当前线程；如果在web环境在请求结束时需要解除绑定；然后获取身份验证的Token，如用户名/密码；<br>4.调用subject.login方法进行登录，其会自动委托给SecurityManager.login方法进行登录；<br>5.如果身份验证失败请捕获AuthenticationException或其子类，常见的如： DisabledAccountException（禁用的帐号）、LockedAccountException（锁定的帐号）、UnknownAccountException（错误的帐号）、ExcessiveAttemptsException（登录失败次数过多）、IncorrectCredentialsException （错误的凭证）、ExpiredCredentialsException（过期的凭证）等，具体请查看其继承关系；对于页面的错误消息展示，最好使用如“用户名/密码错误”而不是“用户名错误”/“密码错误”，防止一些恶意用户非法扫描帐号库；<br>6.最后可以调用subject.logout退出，其会自动委托给SecurityManager.logout方法退出。</p>
<p>从如上代码可总结出身份验证的步骤：<br>1.收集用户身份/凭证，即如用户名/密码；<br>2.调用Subject.login进行登录，如果失败将得到相应的AuthenticationException异常，根据异常提示用户错误信息；否则登录成功；<br>3.最后调用Subject.logout进行退出操作。</p>
<p>流程图如下：<br><img src="/blog/images/201608/3.png" alt></p>
<p>实现代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/login"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/login"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String username, String password, Model model)</span> </span>&#123;</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(username, password);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            subject.login(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.2 Authenticator及AuthenticationStrategy<br>Authenticator的职责是验证用户帐号，是Shiro API中身份验证核心的入口点：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AuthenticationInfo <span class="title">authenticate</span><span class="params">(AuthenticationToken authenticationToken)</span>  <span class="keyword">throws</span> AuthenticationException</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果验证成功，将返回AuthenticationInfo验证信息；此信息中包含了身份及凭证；如果验证失败将抛出相应的AuthenticationException实现。</p>
<p>SecurityManager接口继承了Authenticator，另外还有一个ModularRealmAuthenticator实现，其委托给多个Realm进行验证，验证规则通过AuthenticationStrategy接口指定，默认提供的实现：</p>
<p>FirstSuccessfulStrategy：只要有一个Realm验证成功即可，只返回第一个Realm身份验证成功的认证信息，其他的忽略；<br>AtLeastOneSuccessfulStrategy：只要有一个Realm验证成功即可，和FirstSuccessfulStrategy不同，返回所有Realm身份验证成功的认证信息；<br>AllSuccessfulStrategy：所有Realm验证成功才算成功，且返回所有Realm身份验证成功的认证信息，如果有一个失败就失败了。</p>
<p>ModularRealmAuthenticator默认使用AtLeastOneSuccessfulStrategy策略。</p>
<p>3.3 授权流程<br>授权，也叫访问控制，即在应用中控制谁能访问哪些资源（如访问页面/编辑数据/页面操作等）。在授权中需了解的几个关键对象：主体（Subject）、资源（Resource）、权限（Permission）、角色（Role）。</p>
<p>主体，即访问应用的用户，在Shiro中使用Subject代表该用户。用户只有授权后才允许访问相应的资源。<br>资源，在应用中用户可以访问的任何东西，比如访问JSP页面、查看/编辑某些数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问。<br>权限，安全策略中的原子授权单位，通过权限我们可以表示在应用中用户有没有操作某个资源的权力。即权限表示在应用中用户能不能访问某个资源，如：访问用户列表页面，查看/新增/修改/删除用户数据（即很多时候都是CRUD（增查改删）式权限控制），打印文档等等…</p>
<p>如上可以看出，权限代表了用户有没有操作某个资源的权利，即反映在某个资源上的操作允不允许，不反映谁去执行这个操作。所以后续还需要把权限赋予给用户，即定义哪个用户允许在某个资源上做什么操作（权限），Shiro不会去做这件事情，而是由实现人员提供。</p>
<p>角色，角色代表了操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便。典型的如：项目经理、技术总监、CTO、开发工程师等都是角色，不同的角色拥有一组不同的权限。<br>隐式角色：即直接通过角色来验证用户有没有操作权限，如在应用中CTO、技术总监、开发工程师可以使用打印机，假设某天不允许开发工程师使用打印机，此时需要从应用中删除相应代码；再如在应用中CTO、技术总监可以查看用户、查看权限；突然有一天不允许技术总监查看用户、查看权限了，需要在相关代码中把技术总监角色从判断逻辑中删除掉；即粒度是以角色为单位进行访问控制的，粒度较粗；如果进行修改可能造成多处代码修改。<br>显示角色：在程序中通过权限控制谁能访问某个资源，角色聚合一组权限集合；这样假设哪个角色不能访问某个资源，只需要从角色代表的权限集合中移除即可；无须修改多处代码；即粒度是以资源/实例为单位的；粒度较细。</p>
<p>流程如下：<br>1.首先调用Subject.isPermitted<em>/hasRole</em>接口，其会委托给SecurityManager，而SecurityManager接着会委托给Authorizer；<br>2.Authorizer是真正的授权者，如果我们调用如isPermitted(“user:view”)，其首先会通过PermissionResolver把字符串转换成相应的Permission实例；<br>3.在进行授权之前，其会调用相应的Realm获取Subject相应的角色/权限用于匹配传入的角色/权限；<br>4.Authorizer会判断Realm的角色/权限是否和传入的匹配，如果有多个Realm，会委托给ModularRealmAuthorizer进行循环判断，如果匹配如isPermitted<em>/hasRole</em>会返回true，否则返回false表示授权失败。</p>
<p>ModularRealmAuthorizer进行多Realm匹配流程：<br>1.首先检查相应的Realm是否实现了实现了Authorizer；<br>2.如果实现了Authorizer，那么接着调用其相应的isPermitted<em>/hasRole</em>接口进行匹配；<br>3.如果有一个Realm匹配那么将返回true，否则返回false。</p>
<p>如果Realm进行授权的话，应该继承AuthorizingRealm，其流程是：<br>1.如果调用hasRole*，则直接获取AuthorizationInfo.getRoles()与传入的角色比较即可；<br>2.首先如果调用如isPermitted(“user:view”)，首先通过PermissionResolver将权限字符串转换成相应的Permission实例，默认使用WildcardPermissionResolver，即转换为通配符的WildcardPermission；<br>3.通过AuthorizationInfo.getObjectPermissions()得到Permission实例集合；通过AuthorizationInfo. getStringPermissions()得到字符串集合并通过PermissionResolver解析为Permission实例；然后获取用户的角色，并通过RolePermissionResolver解析角色对应的权限集合（默认没有实现，可以自己提供）；<br>4.接着调用Permission. implies(Permission p)逐个与传入的权限比较，如果有匹配的则返回true，否则false。 </p>
<p>3.4 Authorizer、PermissionResolver及RolePermissionResolver<br>Authorizer的职责是进行授权（访问控制），是Shiro API中授权核心的入口点，其提供了相应的角色/权限判断接口，具体请参考其Javadoc。SecurityManager继承了Authorizer接口，且提供了ModularRealmAuthorizer用于多Realm时的授权匹配。PermissionResolver用于解析权限字符串到Permission实例，而RolePermissionResolver用于根据角色解析相应的权限集合。</p>
<p>我们可以通过如下配置更改Authorizer实现：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">&lt;!--自定义permissionResolver--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"urlPermissionResolver"</span> <span class="attr">class</span>=<span class="string">"com.github.wzguo.service.shiro.resolver.WebUrlPermissionResolver"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"authorizer"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.authz.ModularRealmAuthorizer"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"permissionResolver"</span> <span class="attr">ref</span>=<span class="string">"urlPermissionResolver"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authorizer"</span> <span class="attr">ref</span>=<span class="string">"authorizer"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>流程图如下：<br><img src="/blog/images/201608/6.png" alt></p>
<p>实现代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@RequestMapping</span>(params = <span class="string">"myjsp"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">		<span class="keyword">if</span>(currentUser.isPermitted(<span class="string">"user.do?myjsp"</span>))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"my"</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"error/noperms"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@RequestMapping</span>(params = <span class="string">"notmyjsp"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">nopermission</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">		<span class="keyword">if</span>(currentUser.isPermitted(<span class="string">"user.do?notmyjsp"</span>))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"notmyjsp"</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"error/noperms"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.拦截器<br>4.1 拦截器介绍<br>Shiro使用了与Servlet一样的Filter接口进行扩展,首先下图是Shiro拦截器的基础类图：<br><img src="/blog/images/201608/7.png" alt></p>
<p>NameableFilter<br>NameableFilter给Filter起个名字，如果没有设置默认就是FilterName；还记得之前的如authc吗？当我们组装拦截器链时会根据这个名字找到相应的拦截器实例；</p>
<p>OncePerRequestFilter<br>OncePerRequestFilter用于防止多次执行Filter的；也就是说一次请求只会走一次拦截器链；另外提供enabled属性，表示是否开启该拦截器实例，默认enabled=true表示开启，如果不想让某个拦截器工作，可以设置为false即可。</p>
<p>ShiroFilter<br>ShiroFilter是整个Shiro的入口点，用于拦截需要安全控制的请求进行处理，这个之前已经用过了。</p>
<p>AdviceFilter<br>AdviceFilter提供了AOP风格的支持，类似于SpringMVC中的Interceptor：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(ServletRequest request, ServletResponse response, Exception exception)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure></p>
<p>preHandler：类似于AOP中的前置增强；在拦截器链执行之前执行；如果返回true则继续拦截器链；否则中断后续的拦截器链的执行直接返回；进行预处理（如基于表单的身份验证、授权）<br>postHandle：类似于AOP中的后置返回增强；在拦截器链执行完成后执行；进行后处理（如记录执行时间之类的）；<br>afterCompletion：类似于AOP中的后置最终增强；即不管有没有异常都会执行；可以进行清理资源（如接触Subject与线程的绑定之类的）；</p>
<p>PathMatchingFilter<br>PathMatchingFilter提供了基于Ant风格的请求路径匹配功能及拦截器参数解析的功能，如“roles[admin,user]”自动根据“，”分割解析到一个路径参数配置并绑定到相应的路径：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">pathsMatch</span><span class="params">(String path, ServletRequest request)</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">onPreHandle</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception</span></span><br></pre></td></tr></table></figure></p>
<p>pathsMatch：该方法用于path与请求路径进行匹配的方法；如果匹配返回true；<br>onPreHandle：在preHandle中，当pathsMatch匹配一个路径后，会调用opPreHandler方法并将路径绑定参数配置传给mappedValue；然后可以在这个方法中进行一些验证（如角色授权），如果验证失败可以返回false中断流程；默认返回true；也就是说子类可以只实现onPreHandle即可，无须实现preHandle。如果没有path与请求路径匹配，默认是通过的（即preHandle返回true）。</p>
<p>AccessControlFilter<br>AccessControlFilter提供了访问控制的基础功能；比如是否允许访问/当访问拒绝时如何处理等：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception</span>;  </span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception</span>;  </span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure></p>
<p>isAccessAllowed：表示是否允许访问；mappedValue就是[urls]配置中拦截器参数部分，如果允许访问返回true，否则false；<br>onAccessDenied：表示当访问拒绝时是否已经处理了；如果返回true表示需要继续处理；如果返回false表示该拦截器实例已经处理了，将直接返回即可。</p>
<p>onPreHandle会自动调用这两个方法决定是否继续处理：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">onPreHandle</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> isAccessAllowed(request, response, mappedValue) || onAccessDenied(request, response, mappedValue);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外AccessControlFilter还提供了如下方法用于处理如登录成功后/重定向到上一个请求：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLoginUrl</span><span class="params">(String loginUrl)</span> <span class="comment">//身份验证时使用，默认/login.jsp  </span></span></span><br><span class="line"><span class="function">String <span class="title">getLoginUrl</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">Subject <span class="title">getSubject</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="comment">//获取Subject实例  </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isLoginRequest</span><span class="params">(ServletRequest request, ServletResponse response)</span><span class="comment">//当前请求是否是登录请求  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveRequestAndRedirectToLogin</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> IOException <span class="comment">//将当前请求保存起来并重定向到登录页面  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveRequest</span><span class="params">(ServletRequest request)</span> <span class="comment">//将请求保存起来，如登录成功后再重定向回该请求  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redirectToLogin</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="comment">//重定向到登录页面</span></span></span><br></pre></td></tr></table></figure></p>
<p>比如基于表单的身份验证就需要使用这些功能。</p>
<p>到此基本的拦截器就完事了，如果我们想进行访问访问的控制就可以继承AccessControlFilter；如果我们要添加一些通用数据我们可以直接继承PathMatchingFilter。</p>
<p>4.2 拦截器链<br>Shiro对Servlet容器的FilterChain进行了代理，即ShiroFilter在继续Servlet容器的Filter链的执行之前，通过ProxiedFilterChain对Servlet容器的FilterChain进行了代理；即先走Shiro自己的Filter体系，然后才会委托给Servlet容器的FilterChain进行Servlet容器级别的Filter链执行；Shiro的ProxiedFilterChain执行流程：1、先执行Shiro自己的Filter链；2、再执行Servlet容器的Filter链（即原始的Filter）。<br>而ProxiedFilterChain是通过FilterChainResolver根据配置文件中[urls]部分是否与请求的URL是否匹配解析得到的。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">FilterChain <span class="title">getChain</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain originalChain)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>即传入原始的chain得到一个代理的chain。<br>Shiro内部提供了一个路径匹配的FilterChainResolver实现：PathMatchingFilterChainResolver，其根据[urls]中配置的url模式（默认Ant风格）=拦截器链和请求的url是否匹配来解析得到配置的拦截器链的；而PathMatchingFilterChainResolver内部通过FilterChainManager维护着拦截器链，比如DefaultFilterChainManager实现维护着url模式与拦截器链的关系。因此我们可以通过FilterChainManager进行动态动态增加url模式与拦截器链的关系。</p>
<p>DefaultFilterChainManager会默认添加org.apache.shiro.web.filter.mgt.DefaultFilter中声明的拦截器：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> DefaultFilter &#123;  </span><br><span class="line">    anon(AnonymousFilter<span class="class">.<span class="keyword">class</span>),  </span></span><br><span class="line"><span class="class">    <span class="title">authc</span>(<span class="title">FormAuthenticationFilter</span>.<span class="title">class</span>),  </span></span><br><span class="line"><span class="class">    <span class="title">authcBasic</span>(<span class="title">BasicHttpAuthenticationFilter</span>.<span class="title">class</span>),  </span></span><br><span class="line"><span class="class">    <span class="title">logout</span>(<span class="title">LogoutFilter</span>.<span class="title">class</span>),  </span></span><br><span class="line"><span class="class">    <span class="title">noSessionCreation</span>(<span class="title">NoSessionCreationFilter</span>.<span class="title">class</span>),  </span></span><br><span class="line"><span class="class">    <span class="title">perms</span>(<span class="title">PermissionsAuthorizationFilter</span>.<span class="title">class</span>),  </span></span><br><span class="line"><span class="class">    <span class="title">port</span>(<span class="title">PortFilter</span>.<span class="title">class</span>),  </span></span><br><span class="line"><span class="class">    <span class="title">rest</span>(<span class="title">HttpMethodPermissionFilter</span>.<span class="title">class</span>),  </span></span><br><span class="line"><span class="class">    <span class="title">roles</span>(<span class="title">RolesAuthorizationFilter</span>.<span class="title">class</span>),  </span></span><br><span class="line"><span class="class">    <span class="title">ssl</span>(<span class="title">SslFilter</span>.<span class="title">class</span>),  </span></span><br><span class="line"><span class="class">    <span class="title">user</span>(<span class="title">UserFilter</span>.<span class="title">class</span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果要注册自定义拦截器，IniSecurityManagerFactory/WebIniSecurityManagerFactory在启动时会自动扫描ini配置文件中的[filters]/[main]部分并注册这些拦截器到DefaultFilterChainManager；且创建相应的url模式与其拦截器关系链。如果使用Spring后续章节会介绍如果注册自定义拦截器。</p>
<p>如果想自定义FilterChainResolver，可以通过实现WebEnvironment接口完成：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIniWebEnvironment</span> <span class="keyword">extends</span> <span class="title">IniWebEnvironment</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> FilterChainResolver <span class="title">createFilterChainResolver</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//在此处扩展自己的FilterChainResolver  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.createFilterChainResolver();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FilterChain之间的关系。如果想动态实现url-拦截器的注册，就可以通过实现此处的FilterChainResolver来完成，比如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、创建FilterChainResolver  </span></span><br><span class="line">PathMatchingFilterChainResolver filterChainResolver = <span class="keyword">new</span> PathMatchingFilterChainResolver();  </span><br><span class="line"><span class="comment">//2、创建FilterChainManager  </span></span><br><span class="line">DefaultFilterChainManager filterChainManager = <span class="keyword">new</span> DefaultFilterChainManager();  </span><br><span class="line"><span class="comment">//3、注册Filter  </span></span><br><span class="line"><span class="keyword">for</span>(DefaultFilter filter : DefaultFilter.values()) &#123;  </span><br><span class="line">    filterChainManager.addFilter(  </span><br><span class="line">        filter.name(), (Filter) ClassUtils.newInstance(filter.getFilterClass()));  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//4、注册URL-Filter的映射关系  </span></span><br><span class="line">filterChainManager.addToChain(<span class="string">"/login.jsp"</span>, <span class="string">"authc"</span>);  </span><br><span class="line">filterChainManager.addToChain(<span class="string">"/unauthorized.jsp"</span>, <span class="string">"anon"</span>);  </span><br><span class="line">filterChainManager.addToChain(<span class="string">"/**"</span>, <span class="string">"authc"</span>);  </span><br><span class="line">filterChainManager.addToChain(<span class="string">"/**"</span>, <span class="string">"roles"</span>, <span class="string">"admin"</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//5、设置Filter的属性  </span></span><br><span class="line">FormAuthenticationFilter authcFilter =  </span><br><span class="line">         (FormAuthenticationFilter)filterChainManager.getFilter(<span class="string">"authc"</span>);  </span><br><span class="line">authcFilter.setLoginUrl(<span class="string">"/login.jsp"</span>);  </span><br><span class="line">RolesAuthorizationFilter rolesFilter =  </span><br><span class="line">          (RolesAuthorizationFilter)filterChainManager.getFilter(<span class="string">"roles"</span>);  </span><br><span class="line">rolesFilter.setUnauthorizedUrl(<span class="string">"/unauthorized.jsp"</span>);  </span><br><span class="line">  </span><br><span class="line">filterChainResolver.setFilterChainManager(filterChainManager);  </span><br><span class="line"><span class="keyword">return</span> filterChainResolver;</span><br></pre></td></tr></table></figure></p>
<p>此处自己去实现注册filter，及url模式与filter之间的映射关系。可以通过定制FilterChainResolver或FilterChainManager来完成诸如动态URL匹配的实现。</p>
<p>然后再web.xml中进行如下配置Environment：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>shiroEnvironmentClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.github.zhangkaitao.shiro.chapter8.web.env.MyIniWebEnvironment<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>4.3 自定义拦截器<br>通过自定义自己的拦截器可以扩展一些功能，诸如动态url-角色/权限访问控制的实现、根据Subject身份信息获取用户信息绑定到Request（即设置通用数据）、验证码验证、在线用户信息的保存等等，因为其本质就是一个Filter；所以Filter能做的它就能做。</p>
<p>基于表单登录拦截器<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormLoginFilter</span> <span class="keyword">extends</span> <span class="title">PathMatchingFilter</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String loginUrl = <span class="string">"/login.jsp"</span>;  </span><br><span class="line">    <span class="keyword">private</span> String successUrl = <span class="string">"/"</span>;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onPreHandle</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(SecurityUtils.getSubject().isAuthenticated()) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//已经登录过  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) request;  </span><br><span class="line">        HttpServletResponse resp = (HttpServletResponse) response;  </span><br><span class="line">        <span class="keyword">if</span>(isLoginRequest(req)) &#123;  </span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"post"</span>.equalsIgnoreCase(req.getMethod())) &#123;<span class="comment">//form表单提交  </span></span><br><span class="line">                <span class="keyword">boolean</span> loginSuccess = login(req); <span class="comment">//登录  </span></span><br><span class="line">                <span class="keyword">if</span>(loginSuccess) &#123;  </span><br><span class="line">                    <span class="keyword">return</span> redirectToSuccessUrl(req, resp);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//继续过滤器链  </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//保存当前地址并重定向到登录界面  </span></span><br><span class="line">            saveRequestAndRedirectToLogin(req, resp);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">redirectToSuccessUrl</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">        WebUtils.redirectToSavedRequest(req, resp, successUrl);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveRequestAndRedirectToLogin</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">        WebUtils.saveRequest(req);  </span><br><span class="line">        WebUtils.issueRedirect(req, resp, loginUrl);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(HttpServletRequest req)</span> </span>&#123;  </span><br><span class="line">        String username = req.getParameter(<span class="string">"username"</span>);  </span><br><span class="line">        String password = req.getParameter(<span class="string">"password"</span>);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            SecurityUtils.getSubject().login(<span class="keyword">new</span> UsernamePasswordToken(username, password));  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            req.setAttribute(<span class="string">"shiroLoginFailure"</span>, e.getClass());  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLoginRequest</span><span class="params">(HttpServletRequest req)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> pathsMatch(loginUrl, WebUtils.getPathWithinApplication(req));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;   </span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>onPreHandle主要流程：<br>1、首先判断是否已经登录过了，如果已经登录过了继续拦截器链即可；<br>2、如果没有登录，看看是否是登录请求，如果是get方法的登录页面请求，则继续拦截器链（到请求页面），否则如果是get方法的其他页面请求则保存当前请求并重定向到登录页面；<br>3、如果是post方法的登录页面表单提交请求，则收集用户名/密码登录即可，如果失败了保存错误消息到“shiroLoginFailure”并返回到登录页面；<br>4、如果登录成功了，且之前有保存的请求，则重定向到之前的这个请求，否则到默认的成功页面。</p>
<p>任意角色授权拦截器<br>Shiro提供roles拦截器，其验证用户拥有所有角色，没有提供验证用户拥有任意角色的拦截器。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnyRolesFilter</span> <span class="keyword">extends</span> <span class="title">AccessControlFilter</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String unauthorizedUrl = <span class="string">"/unauthorized.jsp"</span>;  </span><br><span class="line">    <span class="keyword">private</span> String loginUrl = <span class="string">"/login.jsp"</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        String[] roles = (String[])mappedValue;  </span><br><span class="line">        <span class="keyword">if</span>(roles == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//如果没有设置角色参数，默认成功  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(String role : roles) &#123;  </span><br><span class="line">            <span class="keyword">if</span>(getSubject(request, response).hasRole(role)) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//跳到onAccessDenied处理  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        Subject subject = getSubject(request, response);  </span><br><span class="line">        <span class="keyword">if</span> (subject.getPrincipal() == <span class="keyword">null</span>) &#123;<span class="comment">//表示没有登录，重定向到登录页面  </span></span><br><span class="line">            saveRequest(request);  </span><br><span class="line">            WebUtils.issueRedirect(request, response, loginUrl);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(unauthorizedUrl)) &#123;<span class="comment">//如果有未授权页面跳转过去  </span></span><br><span class="line">                WebUtils.issueRedirect(request, response, unauthorizedUrl);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则返回401未授权状态码  </span></span><br><span class="line">                WebUtils.toHttp(response).sendError(HttpServletResponse.SC_UNAUTHORIZED);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;   </span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>流程：<br>1、首先判断用户有没有任意角色，如果没有返回false，将到onAccessDenied进行处理；<br>2、如果用户没有角色，接着判断用户有没有登录，如果没有登录先重定向到登录；<br>3、如果用户没有角色且设置了未授权页面（unauthorizedUrl），那么重定向到未授权页面；否则直接返回401未授权错误码。</p>
<p>4.4 默认拦截器<br>Shiro内置了很多默认的拦截器，比如身份验证、授权等相关的。默认拦截器可以参考org.apache.shiro.web.filter.mgt.DefaultFilter中的枚举拦截器：</p>
<p><table><tr><th>拦截器名</th><th>拦截器类</th><th>使用场景</th><th>说明（括号里的表示默认值）</th></tr><tr><td>authc</td><td>FormAuthenticationFilter</td><td>验证</td><td>基于表单的拦截器,如”/<strong><strong>=authc”,如果没有登录会跳到相应的登录页面登录:主要属性:usernameParam:表单提交的用户名参数名(username):passwordParam:表单提交的密码参数名(password):rememberMeParam:表单提交的密码参数名(rememberMe):loginUrl:登录页面地址(/login.jsp):successUrl:登录成功后的默认重定向地址:failureKeyAttribute:登录失败后错误信息存储key(shiroLoginFailure)</strong></strong></td></tr><tr><td>authcBasic</td><td>BasicHttpAuthenticationFilter</td><td>验证</td><td>Basic HTTP身份验证拦截器，主要属性： applicationName：弹出登录框显示的信息（application）Basic HTTP身份验证拦截器,主要属性:applicationName,弹出登录框显示的信息(application)</td></tr><tr><td>logout</td><td>LogoutFilter</td><td>验证</td><td>退出拦截器,主要属性:redirectUrl:退出成功后重定向的地址(/)示例”/logout=logout”</td></tr><tr><td>user</td><td>UserFilter</td><td>验证</td><td>用户拦截器,用户已经身份验证/记住我登录的都可:示例/=user</td></tr><tr><td>anon</td><td>AnonymousFilter</td><td>验证</td><td>匿名拦截器，即不需要登录即可访问:一般用于静态资源过滤:示例”/static/<strong><strong>=anon”</strong></strong></td></tr><tr><td>roles</td><td>RolesAuthorizationFilter</td><td>授权</td><td>角色授权拦截器,验证用户是否拥有所有角色:主要属性:loginUrl:登录页面地址(/login.jsp):unauthorizedUrl:未授权后重定向的地址:示例”/admin/=roles[admin]”</td></tr><tr><td>perms</td><td>PermissionsAuthorizationFilter</td><td>授权</td><td>权限授权拦截器,验证用户是否拥有所有权限:属性和roles一样:示例”/user/**=perms[“user:create”]”</td></tr><tr><td>port</td><td>PortFilter</td><td>授权</td><td>端口拦截器,主要属性:port(80):可以通过的端口:示例”/test= port[80]”,如果用户访问该页面是非80,将自动将请求端口改为80并重定向到该80端口,其他路径/参数等都一样</td></tr><tr><td>rest</td><td>HttpMethodPermissionFilter</td><td>授权</td><td>rest风格拦截器,自动根据请求方法构建权限字符串(GET=read, POST=create,PUT=update,DELETE=delete,HEAD=read,TRACE=read,OPTIONS=read, MKCOL=create)构建权限字符串:示例”/users=rest[user]”,会自动拼出”user:read,user:create,user:update,user:delete”权限字符串进行权限匹配(所有都得匹配,isPermittedAll)</td></tr><tr><td>ssl</td><td>SslFilter</td><td>授权</td><td>SSL拦截器,只有请求协议是https才能通过:否则自动跳转会https端口(443):其他和port拦截器一样SSL拦截器,只有请求协议是https才能通过:否则自动跳转会https端口(443):其他和port拦截器一样</td></tr><tr><td>noSessionCreation</td><td>NoSessionCreationFilter</td><td>其他</td><td>不创建会话拦截器,调用subject.getSession(false)不会有什么问题,但是如果subject.getSession(true)将抛出 DisabledSessionException异常</td></tr></table><br>另外还提供了一个org.apache.shiro.web.filter.authz.HostFilter，即主机拦截器，比如其提供了属性：authorizedIps：已授权的ip地址，deniedIps：表示拒绝的ip地址；不过目前还没有完全实现，不可用。</p>
<p>5.参考文章<br><a href="http://jinnianshilongnian.iteye.com/category/305053">跟我学Shiro</a></p>

        </div>
        <div class="post-tool">
            <a class="btn-weixin-mp" href="javascript:void(0);" data-cid="52" title="95">
                <i class="fa fa-mobile" aria-hidden="true"></i> 打赏
            </a>
        </div>
        
        <div class="post-tags">标签：
            
            <a href="/blog/tags/shiro/">shiro</a>
            
        </div>
        
    </article>
    
<div id="disqus_thread"></div>

<div class="clearfix" style="margin-top: 40px;">
</div>
<!-- UY BEGIN -->
<div id="uyan_frame"></div>
<!-- UY END -->

<!--PC版-->
<div id="SOHUCS" sid="12345678"></div>
<script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js"></script>
<script type="text/javascript">
    window.changyan.api.config({
        appid: 'cyvlGm1zt',
        conf: 'prod_ed7bcebba567a04ee0d7b6bd13d280f8'
    });

    $(function () {
        function hash(text) {
            'use strict';
            var hash = 5381,
                index = text.length;
            while (index) {
                hash = (hash * 33) ^ text.charCodeAt(--index);
            }
            return hash >>> 0;
        }

        $('#SOHUCS').attr({
            "sid": hash(window.location.pathname)
        });
    });
</script>


<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    <!--添加友言评论系统，注释以下代码-->
    //  var disqus_config = function () {
    //      this.page.url = 'http://wuzguo.com/blog/2016/08/02/shiro.html';
    //      this.page.identifier = '2016/08/02/shiro.html';
    //  };
    //  (function () { // DON'T EDIT BELOW THIS LINE
    //      var d = document, disqus_shortname = 'wuzguo', s = d.createElement('script');
    //      s.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
    //      s.setAttribute('data-timestamp', +new Date());
    //      (d.head || d.body).appendChild(s);
    //  })();
</script>

<!--添加友言评论系统，注释以下代码-->
<!--<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>-->

</div>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        </div><!-- end #main-->


    </div><!-- end #body -->
    <footer class="footer">
    <div class="footer-inner">
        <p>
            <a href="/blog/about/" title="关于本站">关于本站</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/blog/help/" title="帮助">帮助</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/blog/video/" title="视频">视频</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <!-- 自定义链接 -->
            <a href="/blog/links/" title="友情链接">友情链接</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/blog/app/" title="应用下载">应用下载</a>
        </p>
        <br>
        <p>哪有什么天生如此，只是我天天坚持，自律给我自由</p>
        <br>
        <p>
            © 2016-2017 本站点基于<a href="http://hexo.io" target="_blank">Hexo</a>搭建
            ，主题作者<a href="https://www.tangkunyin.com" target="_blank">唐先森</a>，
            采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享4.0国际许可协议</a>，已建站<a href="/timeline" id="siteBuildingTime"></a>天<br>
        </p>
        
<p>
    <script type="text/javascript">
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1262530944'%3E%3C/span%3E%3Cscript src='//s4.cnzz.com/stat.php%3Fid%3D1262530944%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"));
    </script>
</p>

    </div>
</footer>
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>
<script src="/blog/css/highlight/highlight.pack.js"></script>
<script src="/blog/js/InsightSearch.js"></script>
<script src="/blog/js/SimpleCore.js"></script>

</div>
<div class="fixed-btn">
    <a class="btn-gotop" href="javascript:"> <i class="fa fa-angle-up"></i></a>
</div>

<script>
    $(function () {
        SimpleCore.init({
            buildingTime: '04/24/2016',
            current: $('.post-tags').length > 0 ? 'post' : 'archive',
            customImg: '/blog/images/weixin-mp.png'
        });

        <!--代码高亮-->
        $('.code pre').each(function (i, block) {
            hljs.highlightBlock(block);
        });
    });
</script>
</body>
</html>